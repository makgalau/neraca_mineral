/**
 * @packageDocumentation
 *
 * Exports a `Helia` class that implements the {@link HeliaInterface} API.
 *
 * In general you should use the `helia` or `@helia/http` modules instead which
 * pre-configure Helia for certain use-cases (p2p or pure-HTTP).
 *
 * @example
 *
 * ```typescript
 * import { Helia } from '@helia/core'
 *
 * const node = new Helia({
 *   // ...options
 * })
 * ```
 */
import { start, stop } from '@libp2p/interface';
import drain from 'it-drain';
import { CustomProgressEvent } from 'progress-events';
import { PinsImpl } from './pins.js';
import { BlockStorage } from './storage.js';
import { defaultDagWalkers } from './utils/dag-walkers.js';
import { assertDatastoreVersionIsCurrent } from './utils/datastore-version.js';
import { defaultHashers } from './utils/default-hashers.js';
import { NetworkedStorage } from './utils/networked-storage.js';
export class Helia {
    libp2p;
    blockstore;
    datastore;
    pins;
    logger;
    log;
    constructor(init) {
        this.logger = init.libp2p.logger;
        this.log = this.logger.forComponent('helia');
        const hashers = defaultHashers(init.hashers);
        const components = {
            blockstore: init.blockstore,
            datastore: init.datastore,
            libp2p: init.libp2p,
            hashers,
            logger: init.libp2p.logger
        };
        const blockBrokers = init.blockBrokers.map((fn) => {
            return fn(components);
        });
        const networkedStorage = new NetworkedStorage(components, {
            blockBrokers,
            hashers
        });
        this.pins = new PinsImpl(init.datastore, networkedStorage, defaultDagWalkers(init.dagWalkers));
        this.libp2p = init.libp2p;
        this.blockstore = new BlockStorage(networkedStorage, this.pins, {
            holdGcLock: init.holdGcLock
        });
        this.datastore = init.datastore;
    }
    async start() {
        await assertDatastoreVersionIsCurrent(this.datastore);
        await start(this.blockstore);
        await this.libp2p.start();
    }
    async stop() {
        await this.libp2p.stop();
        await stop(this.blockstore);
    }
    async gc(options = {}) {
        const releaseLock = await this.blockstore.lock.writeLock();
        try {
            const helia = this;
            const blockstore = this.blockstore.unwrap();
            this.log('gc start');
            await drain(blockstore.deleteMany((async function* () {
                for await (const { cid } of blockstore.getAll()) {
                    try {
                        if (await helia.pins.isPinned(cid, options)) {
                            continue;
                        }
                        yield cid;
                        options.onProgress?.(new CustomProgressEvent('helia:gc:deleted', cid));
                    }
                    catch (err) {
                        helia.log.error('Error during gc', err);
                        options.onProgress?.(new CustomProgressEvent('helia:gc:error', err));
                    }
                }
            }())));
        }
        finally {
            releaseLock();
        }
        this.log('gc finished');
    }
}
export function isLibp2p(obj) {
    if (obj == null) {
        return false;
    }
    // a non-exhaustive list of methods found on the libp2p object
    const funcs = ['dial', 'dialProtocol', 'hangUp', 'handle', 'unhandle', 'getMultiaddrs', 'getProtocols'];
    // if these are all functions it's probably a libp2p object
    return funcs.every(m => typeof obj[m] === 'function');
}
//# sourceMappingURL=index.js.map