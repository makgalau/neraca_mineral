import { TypedEventEmitter } from '@libp2p/interface';
import { CID } from 'multiformats/cid';
import { BitswapMessage } from './pb/message.js';
import type { WantOptions } from './bitswap.js';
import type { MultihashHasherLoader } from './index.js';
import type { Block } from './pb/message.js';
import type { Provider, Routing } from '@helia/interface/routing';
import type { Libp2p, AbortOptions, Connection, PeerId, IncomingStreamData, ComponentLogger } from '@libp2p/interface';
import type { ProgressEvent, ProgressOptions } from 'progress-events';
export type BitswapNetworkProgressEvents = ProgressEvent<'bitswap:network:dial', PeerId>;
export type BitswapNetworkWantProgressEvents = ProgressEvent<'bitswap:network:send-wantlist', PeerId> | ProgressEvent<'bitswap:network:send-wantlist:error', {
    peer: PeerId;
    error: Error;
}> | ProgressEvent<'bitswap:network:find-providers', CID> | BitswapNetworkProgressEvents;
export type BitswapNetworkNotifyProgressEvents = BitswapNetworkProgressEvents | ProgressEvent<'bitswap:network:send-block', PeerId>;
export interface NetworkInit {
    hashLoader?: MultihashHasherLoader;
    maxInboundStreams?: number;
    maxOutboundStreams?: number;
    messageReceiveTimeout?: number;
    messageSendTimeout?: number;
    messageSendConcurrency?: number;
    protocols?: string[];
    runOnTransientConnections?: boolean;
}
export interface NetworkComponents {
    routing: Routing;
    logger: ComponentLogger;
    libp2p: Libp2p;
}
export interface BitswapMessageEventDetail {
    peer: PeerId;
    message: BitswapMessage;
}
export interface NetworkEvents {
    'bitswap:message': CustomEvent<{
        peer: PeerId;
        message: BitswapMessage;
    }>;
    'peer:connected': CustomEvent<PeerId>;
    'peer:disconnected': CustomEvent<PeerId>;
}
export declare class Network extends TypedEventEmitter<NetworkEvents> {
    private readonly log;
    private readonly libp2p;
    private readonly routing;
    private readonly protocols;
    private running;
    private readonly maxInboundStreams;
    private readonly maxOutboundStreams;
    private readonly messageReceiveTimeout;
    private registrarIds;
    private readonly metrics;
    private readonly sendQueue;
    private readonly messageSendTimeout;
    private readonly runOnTransientConnections;
    constructor(components: NetworkComponents, init?: NetworkInit);
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Handles incoming bitswap messages
     */
    _onStream(info: IncomingStreamData): void;
    /**
     * Find bitswap providers for a given `cid`.
     */
    findProviders(cid: CID, options?: AbortOptions & ProgressOptions<BitswapNetworkWantProgressEvents>): AsyncIterable<Provider>;
    /**
     * Find the providers of a given `cid` and connect to them.
     */
    findAndConnect(cid: CID, options?: WantOptions): Promise<void>;
    /**
     * Connect to the given peer
     * Send the given msg (instance of Message) to the given peer
     */
    sendMessage(peerId: PeerId, msg: Partial<BitswapMessage>, options?: AbortOptions & ProgressOptions<BitswapNetworkWantProgressEvents>): Promise<void>;
    /**
     * Connects to another peer
     */
    connectTo(peer: PeerId, options?: AbortOptions & ProgressOptions<BitswapNetworkProgressEvents>): Promise<Connection>;
    _updateSentStats(blocks?: Block[]): void;
}
//# sourceMappingURL=network.d.ts.map