/* eslint-disable max-depth */
import { DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK } from '../constants.js';
import { BlockPresenceType, WantType } from '../pb/message.js';
import { cidToPrefix } from '../utils/cid-prefix.js';
export class Ledger {
    peerId;
    blockstore;
    network;
    wants;
    exchangeCount;
    bytesSent;
    bytesReceived;
    lastExchange;
    maxSizeReplaceHasWithBlock;
    constructor(components, init) {
        this.peerId = components.peerId;
        this.blockstore = components.blockstore;
        this.network = components.network;
        this.wants = new Map();
        this.exchangeCount = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock ?? DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK;
    }
    sentBytes(n) {
        this.exchangeCount++;
        this.lastExchange = (new Date()).getTime();
        this.bytesSent += n;
    }
    receivedBytes(n) {
        this.exchangeCount++;
        this.lastExchange = (new Date()).getTime();
        this.bytesReceived += n;
    }
    debtRatio() {
        return (this.bytesSent / (this.bytesReceived + 1)); // +1 is to prevent division by zero
    }
    async sendBlocksToPeer(options) {
        const message = {
            blockPresences: [],
            blocks: []
        };
        const sentBlocks = new Set();
        for (const [key, entry] of this.wants.entries()) {
            const has = await this.blockstore.has(entry.cid, options);
            if (!has) {
                // we don't have the requested block and the remote is not interested
                // in us telling them that
                if (!entry.sendDontHave) {
                    continue;
                }
                // we have already told them we don't have the block
                if (entry.sentDontHave === true) {
                    continue;
                }
                entry.sentDontHave = true;
                message.blockPresences.push({
                    cid: entry.cid.bytes,
                    type: BlockPresenceType.DontHaveBlock
                });
                continue;
            }
            const block = await this.blockstore.get(entry.cid, options);
            // do they want the block or just us to tell them we have the block
            if (entry.wantType === WantType.WantHave) {
                if (block.byteLength < this.maxSizeReplaceHasWithBlock) {
                    // if the block is small we just send it to them
                    sentBlocks.add(key);
                    message.blocks.push({
                        data: block,
                        prefix: cidToPrefix(entry.cid)
                    });
                }
                else {
                    // otherwise tell them we have the block
                    message.blockPresences.push({
                        cid: entry.cid.bytes,
                        type: BlockPresenceType.HaveBlock
                    });
                }
            }
            else {
                // they want the block, send it to them
                sentBlocks.add(key);
                message.blocks.push({
                    data: block,
                    prefix: cidToPrefix(entry.cid)
                });
            }
        }
        // only send the message if we actually have something to send
        if (message.blocks.length > 0 || message.blockPresences.length > 0) {
            await this.network.sendMessage(this.peerId, message, options);
            // update accounting
            this.sentBytes(message.blocks.reduce((acc, curr) => acc + curr.data.byteLength, 0));
            // remove sent blocks from local copy of their want list - they can still
            // re-request if required
            for (const key of sentBlocks) {
                this.wants.delete(key);
            }
        }
    }
}
//# sourceMappingURL=ledger.js.map