import { createTrustlessGatewaySession } from './session.js';
import { TrustlessGateway } from './trustless-gateway.js';
import { DEFAULT_TRUSTLESS_GATEWAYS } from './index.js';
/**
 * A class that accepts a list of trustless gateways that are queried
 * for blocks.
 */
export class TrustlessGatewayBlockBroker {
    components;
    gateways;
    routing;
    log;
    logger;
    constructor(components, init = {}) {
        this.components = components;
        this.log = components.logger.forComponent('helia:trustless-gateway-block-broker');
        this.logger = components.logger;
        this.routing = components.routing;
        this.gateways = (init.gateways ?? DEFAULT_TRUSTLESS_GATEWAYS)
            .map((gatewayOrUrl) => {
            return new TrustlessGateway(gatewayOrUrl, components.logger);
        });
    }
    addGateway(gatewayOrUrl) {
        this.gateways.push(new TrustlessGateway(gatewayOrUrl, this.components.logger));
    }
    async retrieve(cid, options = {}) {
        // Loop through the gateways until we get a block or run out of gateways
        // TODO: switch to toSorted when support is better
        const sortedGateways = this.gateways.sort((a, b) => b.reliability() - a.reliability());
        const aggregateErrors = [];
        for (const gateway of sortedGateways) {
            this.log('getting block for %c from %s', cid, gateway.url);
            try {
                const block = await gateway.getRawBlock(cid, options.signal);
                this.log.trace('got block for %c from %s', cid, gateway.url);
                try {
                    await options.validateFn?.(block);
                }
                catch (err) {
                    this.log.error('failed to validate block for %c from %s', cid, gateway.url, err);
                    gateway.incrementInvalidBlocks();
                    throw new Error(`Block for CID ${cid} from gateway ${gateway.url} failed validation`);
                }
                return block;
            }
            catch (err) {
                this.log.error('failed to get block for %c from %s', cid, gateway.url, err);
                if (err instanceof Error) {
                    aggregateErrors.push(err);
                }
                else {
                    aggregateErrors.push(new Error(`Unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));
                }
                // if signal was aborted, exit the loop
                if (options.signal?.aborted === true) {
                    this.log.trace('request aborted while fetching raw block for CID %c from gateway %s', cid, gateway.url);
                    break;
                }
            }
        }
        if (aggregateErrors.length > 0) {
            throw new AggregateError(aggregateErrors, `Unable to fetch raw block for CID ${cid} from any gateway`);
        }
        else {
            throw new Error(`Unable to fetch raw block for CID ${cid} from any gateway`);
        }
    }
    createSession(options = {}) {
        return createTrustlessGatewaySession({
            logger: this.logger,
            routing: this.routing
        }, options);
    }
}
//# sourceMappingURL=broker.js.map