import { AbstractSession } from '@helia/utils';
import { isPrivateIp } from '@libp2p/utils/private-ip';
import { DNS, HTTP, HTTPS } from '@multiformats/multiaddr-matcher';
import { multiaddrToUri } from '@multiformats/multiaddr-to-uri';
import { TrustlessGateway } from './trustless-gateway.js';
const DEFAULT_ALLOW_INSECURE = false;
const DEFAULT_ALLOW_LOCAL = false;
class TrustlessGatewaySession extends AbstractSession {
    routing;
    allowInsecure;
    allowLocal;
    constructor(components, init) {
        super(components, {
            ...init,
            name: 'helia:trustless-gateway:session'
        });
        this.routing = components.routing;
        this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
        this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
    }
    async queryProvider(cid, provider, options) {
        this.log('fetching BLOCK for %c from %s', cid, provider.url);
        const block = await provider.getRawBlock(cid, options.signal);
        this.log.trace('got block for %c from %s', cid, provider.url);
        await options.validateFn?.(block);
        return block;
    }
    async *findNewProviders(cid, options = {}) {
        for await (const provider of this.routing.findProviders(cid, options)) {
            // require http(s) addresses
            const httpAddresses = filterMultiaddrs(provider.multiaddrs, this.allowInsecure, this.allowLocal);
            if (httpAddresses.length === 0) {
                continue;
            }
            // take first address?
            // /ip4/x.x.x.x/tcp/31337/http
            // /ip4/x.x.x.x/tcp/31337/https
            // etc
            const uri = multiaddrToUri(httpAddresses[0]);
            this.log('found http-gateway provider %p %s for cid %c', provider.id, uri, cid);
            yield new TrustlessGateway(uri, this.logger);
        }
    }
    toEvictionKey(provider) {
        return provider.url.toString();
    }
    equals(providerA, providerB) {
        return providerA.url.toString() === providerB.url.toString();
    }
}
function filterMultiaddrs(multiaddrs, allowInsecure, allowLocal) {
    return multiaddrs.filter(ma => {
        if (HTTPS.matches(ma) || (allowInsecure && HTTP.matches(ma))) {
            if (allowLocal) {
                return true;
            }
            if (DNS.matches(ma)) {
                return true;
            }
            return isPrivateIp(ma.toOptions().host) === false;
        }
        return false;
    });
}
export function createTrustlessGatewaySession(components, init) {
    return new TrustlessGatewaySession(components, init);
}
//# sourceMappingURL=session.js.map